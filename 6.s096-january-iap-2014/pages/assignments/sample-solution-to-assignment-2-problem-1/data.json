
{
  "title":"Sample Solution to Assignment 2, Problem 1",
  "content":"« Back to Assignments\n#include \u0026lt;\u0026#34;list.h\u0026#34;\u0026gt; #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; struct List_node_s { List_node *next; int value; }; List empty_list( void ) { return (List) { .length = 0, .front = NULL }; } List_node* create_node( int value ) { List_node *new_node = malloc( sizeof( List_node ) ); new_node-\u0026gt;value = value; new_node-\u0026gt;next = NULL; return new_node; } void list_append( List *list, int value ) { if( list-\u0026gt;front == NULL ) { list-\u0026gt;front = create_node( value ); } else { List_node *p = list-\u0026gt;front; for( size_t i = 1; i \u0026lt; list-\u0026gt;length; ++i, p = p-\u0026gt;next ); p-\u0026gt;next = create_node( value ); } ++list-\u0026gt;length; } void list_delete_from_front( List *list, int value ) { List_node *front = list-\u0026gt;front; while( front != NULL \u0026amp;\u0026amp; front-\u0026gt;value == value ) { list-\u0026gt;front = front-\u0026gt;next; --list-\u0026gt;length; free( front ); front = list-\u0026gt;front; } } void list_delete( List *list, int value ) { list_delete_from_front( list, value ); if( list-\u0026gt;front == NULL ) { return; } List_node *prev = list-\u0026gt;front; List_node *p = list-\u0026gt;front-\u0026gt;next; while( p != NULL ) { if( p-\u0026gt;value == value ) { prev-\u0026gt;next = p-\u0026gt;next; free( p ); --list-\u0026gt;length; p = prev-\u0026gt;next; } else { prev = p; p = prev-\u0026gt;next; } } } void list_insert_before( List *list, int insert, int before ) { if( list-\u0026gt;front != NULL \u0026amp;\u0026amp; list-\u0026gt;front-\u0026gt;value == before ) { List_node *new_node = create_node( insert ); new_node-\u0026gt;next = list-\u0026gt;front; list-\u0026gt;front = new_node; ++list-\u0026gt;length; } else { List_node *prev = list-\u0026gt;front; List_node *next = list-\u0026gt;front-\u0026gt;next; while( next != NULL ) { if( next-\u0026gt;value == before ) { prev-\u0026gt;next = create_node( insert ); prev-\u0026gt;next-\u0026gt;next = next; ++list-\u0026gt;length; return; } prev = next; next = next-\u0026gt;next; } } } void list_apply( List *list, int (*function_ptr)( int) ) { for( List_node *p = list-\u0026gt;front; p != NULL; p = p-\u0026gt;next ) { p-\u0026gt;value = (*function_ptr)( p-\u0026gt;value ); } } int list_reduce( List *list, int (*function_ptr)(int, int) ) { if( list-\u0026gt;front == NULL ) { return 0; } int result = list-\u0026gt;front-\u0026gt;value; for( List_node *p = list-\u0026gt;front-\u0026gt;next; p != NULL; p = p-\u0026gt;next ) { result = (*function_ptr) ( result, p-\u0026gt;value ); } return result; } void list_print( List list ) { if( list.front == NULL ) { printf( \u0026#34;{}\\n\u0026#34; ); } else { printf( \u0026#34;{ \u0026#34; ); List_node *p = list.front; size_t length = list.length; while( p-\u0026gt;next != NULL \u0026amp;\u0026amp; length \u0026gt; 0 ) { printf( \u0026#34;%d -\u0026gt; \u0026#34;, p-\u0026gt;value ); p = p-\u0026gt;next; --length; } printf( \u0026#34;%d }\\n\u0026#34;, p-\u0026gt;value ); if( length != 1 ) { printf( \u0026#34;Error: badly formed list.\\n\u0026#34; ); exit( EXIT_FAILURE ); } } } void list_clear( List *list ) { List_node *front = list-\u0026gt;front; size_t length = list-\u0026gt;length; while( front != NULL \u0026amp;\u0026amp; length \u0026gt; 0 ) { List_node *next = front-\u0026gt;next; free( front ); front = next; --length; } if( length != 0 ) { printf( \u0026#34;Error: failed to clean up list properly.\\n\u0026#34; ); exit( EXIT_FAILURE ); } } Below is the output using the test data: list: 1: OK [0.002 seconds] OK! 2: OK [0.004 seconds] OK! 3: OK [0.035 seconds] OK! 4: OK [2.175 seconds] OK! 5: OK [0.133 seconds] OK! 6: OK [0.305 seconds] OK! 7: OK [0.061 seconds] OK! 8: OK [0.213 seconds] OK! 9: OK [0.002 seconds] OK! 10: OK [1.054 seconds] OK! « Back to Assignments\n"}


