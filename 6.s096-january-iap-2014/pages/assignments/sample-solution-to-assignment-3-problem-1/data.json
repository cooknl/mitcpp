
{
  "title":"Sample Solution to Assignment 3, Problem 1",
  "content":"Â« Back to Assignments\nLook in list.h for a sense of the structure of the solution. The big idea to speed up the reduce/apply functions while also giving users a nice way to iterate over the items in the list is to create an \u0026ldquo;iterator\u0026rdquo; type within our class. Users will be able to write code similar to the STL:\n// Print out every item in the list for( List::iterator it = list.begin(); it != list.end(); ++it ) { std::cout \u0026lt; \u0026lt; *it \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } To speed up our \u0026ldquo;append\u0026rdquo; function, the List class will also store a pointer to the very last element in the current list.\nDirectory structure:\nGRADER_INFO.txt include apply.h list.h list_node.h reduce.h Makefile src apply.cpp list.cpp list_iterator.cpp list_node.cpp reduce.cpp test.cpp Here are the contents of apply.h: #ifndef _6S096_CPPLIST_APPLY_H #define _6S096_CPPLIST_APPLY_H #include \u0026#34;list.h\u0026#34; class ApplyFunction { protected: virtual int function( int x ) const = 0; public: void apply( List \u0026amp;list ) const; virtual ~ApplyFunction() {} }; // An example ApplyFunction (see apply.cpp) class SquareApply : public ApplyFunction { int function( int x ) const; }; #endif // _6S096_CPPLIST_APPLY_H Here are the contents of list.h: #ifndef _6S096_CPPLIST_H #define _6S096_CPPLIST_H #include \u0026lt;cstddef\u0026gt; #include \u0026lt;stdexcept\u0026gt; class ApplyFunction; class ReduceFunction; class ListNode; class List { size_t _length; ListNode *_begin; ListNode *_back; public: // Can use outside as List::iterator type class iterator { // Making List a friend class means we\u0026#39;ll be able to access // the private _node pointer data within the scope of List. friend class List; ListNode *_node; public: iterator( ListNode *theNode ); iterator\u0026amp; operator++(); int\u0026amp; operator*(); bool operator==( const iterator \u0026amp;rhs ); bool operator!=( const iterator \u0026amp;rhs ); }; // Can use outside as List::const_iterator type class const_iterator { // Again, this is basically the only situation you should // be using the keyword \u0026#39;friend\u0026#39; friend class List; ListNode *_node; public: const_iterator( ListNode *theNode ); const_iterator\u0026amp; operator++(); const int\u0026amp; operator*(); bool operator==( const const_iterator \u0026amp;rhs ); bool operator!=( const const_iterator \u0026amp;rhs ); }; List(); List( const List \u0026amp;list ); List\u0026amp; operator=( const List \u0026amp;list ); ~List(); size_t length()const; int\u0026amp; value( size_t pos ); int value( size_t pos ) const; bool empty() const; iterator begin(); const_iterator begin() const; iterator back(); const_iterator back() const; iterator end(); const_iterator end() const; iterator find( iterator s, iterator t, int needle ); void append( int theValue ); void deleteAll( int theValue ); void insertBefore( int theValue, int before ); void insert( iterator pos, int theValue ); void apply( const ApplyFunction \u0026amp;interface ); int reduce( const ReduceFunction \u0026amp;interface ) const; void print() const; void clear(); private: ListNode* node( iterator it ) { return it._node; } ListNode* node( const_iterator it ) { return it._node; } }; class ListOutOfBounds : public std::range_error { public: explicit ListOutOfBounds() : std::range_error( \u0026#34;List index out of bounds\u0026#34; ) {} }; #endif // _6S096_CPPLIST_H Here are the contents of list_node.h: #ifndef _6S096_CPPLIST_NODE_H #define _6S096_CPPLIST_NODE_H class ListNode { int _value; ListNode *_next; ListNode( const ListNode \u0026amp; ) = delete; ListNode\u0026amp; operator=( const ListNode \u0026amp; ) = delete; public: ListNode(); ListNode( int theValue ); ~ListNode(); int\u0026amp; value(); int value() const; ListNode* next(); void insertAfter( ListNode *before ); void setNext( ListNode *nextNode ); static void deleteNext( ListNode *before ); static void deleteSection( ListNode *before, ListNode *after ); static ListNode* create( int theValue = 0 ); }; #endif // _6S096_CPPLIST_NODE_H Here are the contents of reduce.h: #ifndef _6S096_CPPLIST_REDUCE_H #define _6S096_CPPLIST_REDUCE_H #include \u0026#34;list.h\u0026#34; class ReduceFunction { protected: virtual int function( int x, int y ) const = 0; public: int reduce( const List \u0026amp;list ) const; virtual int identity() const = 0; virtual ~ReduceFunction() {} }; // An example ReduceFunction class SumReduce : public ReduceFunction { int function( int x, int y ) const; public: SumReduce() {} ~SumReduce() {} int identity() const { return 0; } }; // Another ReduceFunction class ProductReduce : public ReduceFunction { int function( int x, int y ) const; public: ProductReduce() {} ~ProductReduce() {} int identity() const { return 1; } }; #endif // _6S096_CPPLIST_REDUCE_H Here is the source code file apply.cpp: #include \u0026#34;list.h\u0026#34; #include \u0026#34;apply.h\u0026#34; void ApplyFunction::apply( List \u0026amp;list ) const { for( auto it = list.begin(); it != list.end(); ++it ) { *it = function( *it ); } } int SquareApply::function( int x ) const { return x * x; } Here is the source code file list.cpp: #include \u0026#34;list.h\u0026#34; #include \u0026#34;list_node.h\u0026#34; #include \u0026#34;apply.h\u0026#34; #include \u0026#34;reduce.h\u0026#34; #include \u0026lt;iostream\u0026gt; List::List() : _length{0}, _begin{ nullptr }, _back{ nullptr } {} List::List( const List \u0026amp;list ) : _length{0}, _begin{nullptr}, _back{nullptr} { for( auto it = list.begin(); it != list.end(); ++it ) { append( *it ); } } List\u0026amp; List::operator=( const List \u0026amp;list ) { if( this != \u0026amp;list ) { clear(); for( auto it = list.begin(); it != list.end(); ++it ) { append( *it ); } } return *this; } List::~List() { clear(); } size_t List::length() const { return _length; } int\u0026amp; List::value( size_t pos ) { auto it = begin(); for( size_t i = 0; i \u0026lt; pos \u0026amp;\u0026amp; it != end(); ++it, ++i ); if( it == end() ) { throw ListOutOfBounds(); } return *it; } int List::value( size_t pos ) const { auto it = begin(); for( size_t i = 0; i \u0026lt; pos \u0026amp;\u0026amp; it != end(); ++it, ++i ); if( it == end() ) { throw ListOutOfBounds(); } return *it; } bool List::empty() const { return _length == 0; } List::iterator List::begin() { return iterator{ _begin }; } List::const_iterator List::begin() const { return const_iterator{ _begin }; } List::iterator List::back() { return iterator{ _back }; } List::const_iterator List::back() const { return const_iterator{ _back }; } List::iterator List::end() { return iterator{ nullptr }; } List::const_iterator List::end() const { return const_iterator{ nullptr }; } void List::append( int theValue ) { auto *newNode = ListNode::create( theValue ); if( empty() ) { newNode-\u0026gt;setNext( _back ); _begin = newNode; } else { newNode-\u0026gt;insertAfter( _back ); } _back = newNode; ++_length; } void List::deleteAll( int theValue ) { if( !empty() ) { // Delete from the front while( _begin-\u0026gt;value() == theValue \u0026amp;\u0026amp; _begin != _back ) { auto *newBegin = _begin-\u0026gt;next(); delete _begin; _begin = newBegin; --_length; } auto *p = _begin; if( _begin != _back ) { // Normal deletion from interior of list for( ; p-\u0026gt;next() != _back; ) { if( p-\u0026gt;next()-\u0026gt;value() == theValue ) { ListNode::deleteNext( p ); --_length; } else { p = p-\u0026gt;next(); } } // Deleting the last item if( _back-\u0026gt;value() == theValue ) { ListNode::deleteNext( p ); _back = p; --_length; } } else if( _begin-\u0026gt;value() == theValue ) { // Deal with the case where we deleted the whole list _begin = _back = nullptr; _length = 0; } } } List::iterator List::find( iterator s, iterator t, int needle ) { for( auto it = s; it != t; ++it ) { if( *it == needle ) { return it; } } return t; } void List::insert( iterator pos, int theValue ) { auto *posPtr = node( pos ); auto *newNode = ListNode::create( theValue ); newNode-\u0026gt;insertAfter( posPtr ); ++_length; } void List::insertBefore( int theValue, int before ) { if( !empty() ) { if( _begin-\u0026gt;value() == before ) { auto *newNode = ListNode::create( theValue ); newNode-\u0026gt;setNext( _begin ); _begin = newNode; ++_length; } else { auto *p = _begin; for( ; p != _back \u0026amp;\u0026amp; p-\u0026gt;next()-\u0026gt;value() != before; p = p-\u0026gt;next() ); if( p != _back \u0026amp;\u0026amp; p-\u0026gt;next()-\u0026gt;value() == before ) { auto *newNode = ListNode::create( theValue ); newNode-\u0026gt;insertAfter( p ); ++_length; } } } } void List::apply( const ApplyFunction \u0026amp;interface ) { interface.apply( *this ); } int List::reduce( const ReduceFunction \u0026amp;interface ) const { return interface.reduce( *this ); } void List::print() const { std::cout \u0026lt;\u0026lt; \u0026#34;{ \u0026#34;; for( auto it = begin(); it != back(); ++it ) { std::cout \u0026lt;\u0026lt; *it \u0026lt;\u0026lt; \u0026#34; -\u0026gt; \u0026#34;; } if( !empty() ) { std::cout \u0026lt;\u0026lt; *back() \u0026lt;\u0026lt; \u0026#34; \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;}\\n\u0026#34;; } void List::clear() { for( auto *p = _begin; p != nullptr; ) { auto *p_next = p-\u0026gt;next(); delete p; p = p_next; } _length = 0; _begin = nullptr; _back = nullptr; } Here is the source code file list_iterator.cpp: #include \u0026#34;list.h\u0026#34; #include \u0026#34;list_node.h\u0026#34; List::iterator::iterator( ListNode *theNode ) : _node{theNode} {} List::iterator\u0026amp; List::iterator::operator++() { _node = _node-\u0026gt;next(); return *this; } int\u0026amp; List::iterator::operator*() { return _node-\u0026gt;value(); } bool List::iterator::operator==( const iterator \u0026amp;rhs ) { return _node == rhs._node; } bool List::iterator::operator!=( const iterator \u0026amp;rhs ) { return _node != rhs._node; } List::const_iterator::const_iterator( ListNode *theNode ) : _node{theNode} {} List::const_iterator\u0026amp; List::const_iterator::operator++() { _node = _node-\u0026gt;next(); return *this; } const int\u0026amp; List::const_iterator::operator*() { return _node-\u0026gt;value(); } bool List::const_iterator::operator==( const const_iterator \u0026amp;rhs ) { return _node == rhs._node; } bool List::const_iterator::operator!=( const const_iterator \u0026amp;rhs ) { return _node != rhs._node; } Here is the source code file list_node.cpp: #include \u0026#34;list_node.h\u0026#34; ListNode::ListNode() : _value{0}, _next{nullptr} {} ListNode::ListNode( int theValue ) : _value{theValue}, _next{nullptr} {} ListNode::~ListNode() {} int\u0026amp; ListNode::value() { return _value; } int ListNode::value(){const { return _value; } ListNode* ListNode::next() { return _next; } void ListNode::insertAfter( ListNode *before ) { _next = before-\u0026gt;next(); before-\u0026gt;_next = this; } void ListNode::setNext( ListNode *nextNode ) { _next = nextNode; } void ListNode::deleteNext( ListNode *before ) { auto *after = before-\u0026gt;next()-\u0026gt;next(); delete before-\u0026gt;next(); before-\u0026gt;_next = after; } void ListNode::deleteSection( ListNode *before, ListNode *after ) { auto *deleteFront = before-\u0026gt;next(); while( deleteFront != after ) { auto *nextDelete = deleteFront-\u0026gt;next(); delete deleteFront; deleteFront = nextDelete; } } ListNode* ListNode::create( int theValue ) { return new ListNode{ theValue }; } Here is the source code file reduce.cpp: #include \u0026#34;list.h\u0026#34; #include \u0026#34;reduce.h\u0026#34; int ReduceFunction::reduce(const List \u0026amp;list ) const { int result = identity(); for( auto it = list.begin(); it != list.end(); ++it ) { result = function( result, *it ); } return result; } int SumReduce::function( int x, int y ) const { return x + y; } int ProductReduce::function(int x, int y ) const { return x * y; } Below is the output using the test data: cpplist: 1: OK [0.004 seconds] OK! 2: OK [0.005 seconds] OK! 3: OK [0.005 seconds] OK! 4: OK [0.009 seconds] OK! 5: OK [0.006 seconds] OK! 6: OK [0.308 seconds] OK! 7: OK [0.053 seconds] OK! 8: OK [0.007 seconds] OK! 9: OK [0.005 seconds] OK! 10: OK [0.742 seconds] OK! Â« Back to Assignments\n"}


