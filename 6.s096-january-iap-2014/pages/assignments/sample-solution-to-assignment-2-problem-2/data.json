
{
  "title":"Sample Solution to Assignment 2, Problem 2",
  "content":"« Back to Assignments\n/* PROG: mst LANG: C++ */ #include \u0026lt;vector\u0026gt; #include \u0026lt;queue\u0026gt; #include \u0026lt;fstream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;iomanip\u0026gt; #include \u0026lt;unordered_map\u0026gt; class State { size_t _node; double _dist; public: State( size_t aNode, double aDist ) : _node{aNode}, _dist{aDist} {} inline size_t node()const { return _node; } inline double dist()const { return _dist; } }; class AdjacencyList { std::vector\u0026lt; std::vector\u0026lt; State\u0026gt; \u0026gt; _adj; AdjacencyList() = delete; public: AdjacencyList( std::istream \u0026amp;input ); inline size_t size() const { return _adj.size(); } inline const std::vector\u0026amp; adj(size_t node ) const { return _adj[node]; } void print(); }; inline bool operator\u0026lt;( const State \u0026amp;a, const State \u0026amp;b ) { return a.dist() \u0026gt; b.dist(); } AdjacencyList::AdjacencyList( std::istream \u0026amp;input ) : _adj{} { size_t nNodes; size_t nEdges; input \u0026gt;\u0026gt; nNodes \u0026gt;\u0026gt; nEdges; _adj.resize( nNodes ); for( size_t e = 0; e \u0026lt; nEdges; ++e ) { size_t v, w; double weight; input \u0026gt;\u0026gt; v \u0026gt;\u0026gt; w \u0026gt;\u0026gt; weight; // Add this edge to both the v and w lists _adj[v].push_back( State{ w, weight } ); _adj[w].push_back( State{ v, weight } ); } } void AdjacencyList::print() { for( size_t i = 0; i \u0026lt; _adj.size(); ++i ) { std::cout \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026#34;: \u0026#34;; for( auto state : _adj[i] ) { std::cout \u0026lt;\u0026lt; \u0026#34;(\u0026#34; \u0026lt;\u0026lt; state.node() \u0026lt;\u0026lt; \u0026#34;, \u0026#34; \u0026lt;\u0026lt; state.dist() \u0026lt;\u0026lt; \u0026#34;) \u0026#34;; } std::cout \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } } double prim( const AdjacencyList \u0026amp;adj ) { std::unordered_map\u0026lt;int, bool\u0026gt; visited; std::priority_queue\u0026lt;State\u0026gt; pq; pq.push( State{ 0, 0.0 } ); double weight = 0.0; while( visited.size() \u0026lt; adj.size() ) { auto top = pq.top(); pq.pop(); if( visited.count( top.node() ) == 0 ) { visited[top.node()] = true; weight += top.dist(); for( auto vertex : adj.adj( top.node() ) ) { pq.push( vertex ); } } } return weight; } int main() { std::ifstream input{ \u0026#34;mst.in\u0026#34; }; std::ofstream output{ \u0026#34;mst.out\u0026#34; }; if( input.is_open() ) { auto adj = AdjacencyList{ input }; output \u0026lt;\u0026lt; std::fixed \u0026lt;\u0026lt; std::setprecision( 8 ); output \u0026lt;\u0026lt; prim( adj ) \u0026lt;\u0026lt; \u0026#34;\\n\u0026#34;; } else { std::cerr \u0026lt;\u0026lt; \u0026#34;Could not open mst.in\\n\u0026#34;; return 1; } return 0; } Below is the output using the test data: mst: 1: OK [0.004 seconds] 2: OK [0.004 seconds] 3: OK [0.004 seconds] 4: OK [0.006 seconds] 5: OK [0.093 seconds] 6: OK [0.122 seconds] 7: OK [0.227 seconds] 8: OK [0.229 seconds] 9: OK [0.285 seconds] 10: OK [0.287 seconds] « Back to Assignments\n"}


