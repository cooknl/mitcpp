
{
  "title":"Sample Solution to Assignment 1, Problem 3",
  "content":"« Back to Assignments\n/* PROG: matrix2 LANG: C */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;string.h\u0026gt; typedef struct Matrix_s { size_t R, C; int *index; } Matrix; Matrix* allocate_matrix( size_t R, size_t C ) { Matrix *matrix = malloc( sizeof( Matrix ) ); matrix-\u0026gt;R = R; matrix-\u0026gt;C = C; matrix-\u0026gt;index = malloc( R * C * sizeof( int ) ); return matrix; } void destroy_matrix( Matrix *matrix ) { free( matrix-\u0026gt;index ); free( matrix ); } typedef enum { REGULAR = 0, TRANSPOSE = 1 } Transpose; // Allowing reading a matrix in as either regular or transposed Matrix* read_matrix( FILE *input, Transpose orient ) { size_t R, C; fscanf( input, \u0026#34;%zu %zu\u0026#34;, \u0026amp;R, \u0026amp;C ); Matrix *matrix = NULL; if( orient == REGULAR ) { matrix = allocate_matrix( R, C ); for( size_t r = 0; r \u0026lt; matrix-\u0026gt;R; ++r ) { for( size_t c = 0; c \u0026lt; matrix-\u0026gt;C; ++c ) { fscanf( input, \u0026#34;%d\u0026#34;, \u0026amp;matrix-\u0026gt;index[c + r * C] ); } } } else if( orient == TRANSPOSE ) { matrix = allocate_matrix( C, R ); for( size_t r = 0; r \u0026lt; matrix-\u0026gt;C; ++r ) { for( size_t c = 0; c \u0026lt; matrix-\u0026gt;R; ++c ) { fscanf( input, \u0026#34;%d\u0026#34;, \u0026amp;matrix-\u0026gt;index[r + c * R] ); } } } else { fprintf( stderr, \u0026#34;Error: unknown orientation %d.\\n\u0026#34;, orient ); exit( EXIT_FAILURE ); } return matrix; } void print_matrix( FILE *output, Matrix *matrix ) { fprintf( output, \u0026#34;%zu %zu\\n\u0026#34;, matrix-\u0026gt;R, matrix-\u0026gt;C ); for( size_t r = 0; r \u0026lt; matrix-\u0026gt;R; ++r ) { for( size_t c = 0; c \u0026lt; matrix-\u0026gt;C - 1; ++c ) { fprintf( output, \u0026#34;%d \u0026#34;, matrix-\u0026gt;index[c + r * matrix-\u0026gt;C] ); } fprintf( output, \u0026#34;%d\\n\u0026#34;, matrix-\u0026gt;index[matrix-\u0026gt;C - 1 + r * matrix-\u0026gt;C] ); } } Matrix* product_matrix( Matrix *a, Matrix *b ) { if( a-\u0026gt;C != b-\u0026gt;C ) { printf( \u0026#34;Error: tried to multiply (%zux%zu)x(%zux%zu)\\n\u0026#34;, a-\u0026gt;R, a-\u0026gt;C, b-\u0026gt;C, b-\u0026gt;R ); exit( EXIT_FAILURE ); } Matrix *prod = allocate_matrix( a-\u0026gt;R, b-\u0026gt;R ); size_t nRows = prod-\u0026gt;R, nCols = prod-\u0026gt;C, nInner = a-\u0026gt;C; for( size_t r = 0; r \u0026lt; nRows; ++r ) { for( size_t c = 0; c \u0026lt; nCols; ++c ) { prod-\u0026gt;index[c + r * nCols] = 0; for( size_t i = 0; i \u0026lt; nInner; ++i ) { prod-\u0026gt;index[c + r * nCols] += a-\u0026gt;index[i + r * nInner] * b-\u0026gt;index[i + c * nInner]; } } } return prod; } int main(void) { FILE *fin = fopen( \u0026#34;matrix2.in\u0026#34;, \u0026#34;r\u0026#34; ); if( fin == NULL ) { printf( \u0026#34;Error: could not open matrix2.in\\n\u0026#34; ); exit( EXIT_FAILURE ); } Matrix *a = read_matrix( fin, REGULAR ); Matrix *b = read_matrix( fin, TRANSPOSE ); fclose( fin ); Matrix *c = product_matrix( a, b ); FILE *output = fopen( \u0026#34;matrix2.out\u0026#34;, \u0026#34;w\u0026#34; ); if( output == NULL ) { printf( \u0026#34;Error: could not open matrix2.out\\n\u0026#34; ); exit( EXIT_FAILURE ); } print_matrix( output, c ); fclose( output ); destroy_matrix( a ); destroy_matrix( b ); destroy_matrix( c ); return 0; } Below is the output using the test data:\nmatrix2: 1: OK [0.006 seconds] 2: OK [0.007 seconds] 3: OK [0.007 seconds] 4: OK [0.019 seconds] 5: OK [0.017 seconds] 6: OK [0.109 seconds] 7: OK [0.178 seconds] 8: OK [0.480 seconds] 9: OK [0.791 seconds] 10: OK [1.236 seconds] 11: OK [2.088 seconds] « Back to Assignments "}


