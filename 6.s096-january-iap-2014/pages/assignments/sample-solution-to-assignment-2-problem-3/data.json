
{
  "title":"Sample Solution to Assignment 2, Problem 3",
  "content":"« Back to Assignments\nHere are the contents of rational.h: #ifndef _6S096_RATIONAL_H #define _6S096_RATIONAL_H #include \u0026lt;cstdint\u0026gt; #include \u0026lt;iosfwd\u0026gt; #include \u0026lt;stdexcept\u0026gt; class Rational { intmax_t _num, _den; public: enum sign_type { POSITIVE, NEGATIVE }; Rational() : _num{0}, _den{1} {} Rational( intmax_t numer ) : _num{numer}, _den{1} {} Rational( intmax_t numer, intmax_t denom ) : _num{numer}, _den{denom} { normalize(); } inline intmax_t num() const { return _num; } inline intmax_t den() const { return _den; } void normalize(); float to_float()const; double to_double()const; sign_type sign() const; Rational inverse() const; }; std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, const Rational \u0026amp;ratio ); inline bool operator==( const Rational \u0026amp;lhs, const Rational \u0026amp;rhs ) { return lhs.num() * rhs.den() == rhs.num() * lhs.den(); } inline bool operator\u0026lt;( const Rational \u0026amp;lhs, const Rational \u0026amp;rhs ) { if( lhs.sign() == Rational::POSITIVE \u0026amp;\u0026amp; rhs.sign() == Rational::POSITIVE ) { return lhs.num() * rhs.den() \u0026lt; rhs.num() * lhs.den(); } else if( lhs.sign() == Rational::NEGATIVE \u0026amp;\u0026amp; rhs.sign() == Rational::NEGATIVE ) { return lhs.num() * rhs.den() \u0026gt; rhs.num() * lhs.den(); } else { return lhs.sign() == Rational::NEGATIVE; } } inline Rational operator*( const Rational \u0026amp;a, const Rational \u0026amp;b ) { return Rational{ a.num() * b.num(), a.den() * b.den() }; } inline Rational operator+( const Rational \u0026amp;a, const Rational \u0026amp;b ) { return Rational{ a.num() * b.den() + b.num() * a.den(), a.den() * b.den() }; } inline Rational operator-( const Rational \u0026amp;a, const Rational \u0026amp;b ) { return Rational{ a.num() * b.den() - b.num() * a.den(), a.den() * b.den() }; } inline Rational operator/( const Rational \u0026amp;a, const Rational \u0026amp;b ) { return a * b.inverse(); } class bad_rational : public std::domain_error { public: explicit bad_rational() : std::domain_error(\u0026#34;Bad rational: zero denominator\u0026#34; ) {} }; #endif // _6S096_RATIONAL_H Here is the source code file rational.cpp: #include \u0026#34;rational.h\u0026#34; #include \u0026#34;gcd.h\u0026#34; #include \u0026lt;stdexcept\u0026gt; #include \u0026lt;ostream\u0026gt; #include \u0026lt;iostream\u0026gt; #include \u0026lt;cmath\u0026gt; Rational Rational::inverse() const { return Rational{ _den, _num }; } Rational::sign_type Rational::sign()const { return _num \u0026gt;= 0 ? POSITIVE : NEGATIVE; } std::ostream\u0026amp; operator\u0026lt;\u0026lt;( std::ostream\u0026amp; os, const Rational \u0026amp;ratio ) { if( ratio == 0 ) { os \u0026lt;\u0026lt; \u0026#34;0\u0026#34;; } else { if( ratio.sign() == Rational::NEGATIVE ) { os \u0026lt;\u0026lt; \u0026#34;-\u0026#34;; } os \u0026lt;\u0026lt; std::abs( ratio.num() ) \u0026lt;\u0026lt; \u0026#34;/\u0026#34; \u0026lt;\u0026lt; std::abs( ratio.den() ); } return os; } void Rational::normalize() { if( _den == 0 ) { throw bad_rational(); } if( _num == 0 ) { _den = 1; return; } auto g = gcd( std::abs( _num ), std::abs( _den ) ); _num /= g; _den /= g; if( _den \u0026lt; 0 ) { _num = -_num; _den = -_den; } } float Rational::to_float() const { return static_cast\u0026lt;float\u0026gt;( _num ) / static_cast\u0026lt;float\u0026gt;( _den ); } double Rational::to_double()const { return static_cast\u0026lt;double\u0026gt;( _num ) / static_cast\u0026lt;double\u0026gt;( _den ); } Below is the output using the test data: rational: 1: OK [0.007 seconds] OK! add 2: OK [0.006 seconds] OK! mult 3: OK [0.009 seconds] OK! add1024 4: OK [0.014 seconds] OK! add1024 5: OK [0.158 seconds] OK! add32768 6: OK [0.007 seconds] OK! op\u0026lt;\u0026lt; 7: OK [0.289 seconds] OK! div65536 in 0.280000 s 8: OK [0.006 seconds] OK! phi, 0.000000e+00 9: OK [0.006 seconds] OK! (Bad rational: zero denominator) 10: OK [0.006 seconds] OK! xyz 11: OK [0.007 seconds] OK! pow2 12: OK [0.006 seconds] OK! x1z « Back to Assignments\n"}


