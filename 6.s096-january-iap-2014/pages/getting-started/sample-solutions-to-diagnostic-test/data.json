
{
  "title":"Sample Solutions to Diagnostic Test",
  "content":"« Back to Getting Started\nThe following are sample solutions to problems 8, 9, and 10 of the diagnostic test.\n/* Notes: as we will be doing in the class, diagnostic.c should be compiled with * \u0026#34;gcc -std=c99 -m64 -Wall -Wextra -Wshadow -Werror -pedantic\u0026#34; * (in particular: we are coding by the C99 standard) */ #include \u0026lt;stdio.h\u0026gt; #include \u0026lt;stdbool.h\u0026gt; #include \u0026lt;stdlib.h\u0026gt; #include \u0026lt;assert.h\u0026gt; /************ PROBLEM 8 ************/ bool is_prime( int n ) { if( n \u0026lt;= 2 || n % 2 == 0 ) { return ( n == 2 ); } for( int i = 3; i * i \u0026lt;= n; i += 2 ) { if( n % i == 0 ) { return false; } } return true; } /************ PROBLEM 9 ************/ void swap( int *a, int *b ) { int t = *a; *a = *b; *b = t; } void permute( int *digits, int n, int p ) { if( p == n ) { for( int i = 0; i \u0026lt; n; ++i ) { printf( \u0026#34;%d \u0026#34;, digits[i] ); } printf( \u0026#34;\\n\u0026#34; ); } else { for( int i = p; i \u0026lt; n; ++i ) { swap( \u0026amp;digits[p], \u0026amp;digits[i] ); permute( digits, n, p + 1 ); swap( \u0026amp;digits[p], \u0026amp;digits[i] ); } } } void print_permutations( int n ) { int *digits = malloc( n * sizeof( int ) ); for( int i = 0; i \u0026lt; n; ++i ) { digits[i] = i + 1; } permute( digits, n, 0 ); free( digits ); } /************ PROBLEM 10 ************/ size_t search( int *data, size_t N, int value ) { for( size_t i = 0; i \u0026lt; N; ++i ) { if( data[i] == value ) { return i; } } return N; } size_t binary_search( int *data, size_t N, int value ) { size_t lo = 0, hi = N - 1; while( lo \u0026lt; hi ) { size_t mid = lo + ( hi - lo ) / 2; if( data[mid] \u0026lt; value ) { lo = mid + 1; } else { hi = mid; } } return ( hi == lo \u0026amp;\u0026amp; data[lo] == value ) ? lo : N; } /************ TESTING ************/ void test_is_prime(void) { int N_prime = 10, N_composite = 20; int prime[] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; int composite[] = { 1, 4, 6, 8, 9, 10, 12, 14, 15, 16, 18, 20, 21, 22, 24, 25, 26, 27, 28 }; for( int i = 0; i \u0026lt; N_prime; ++i ) { assert( is_prime( prime[i] ) ); } for( int i = 0; i \u0026lt; N_composite; ++i ) { assert( !is_prime( composite[i] ) ); } } void test_print_permutations(void) { print_permutations( 3 ); } void test_search(void) { size_t N = 7; int data[] = { 1, 2, 3, 5, 9, 11, 101 }; assert( search( data, N, 0 ) == 7 ); assert( search( data, N, 10 ) == 7 ); assert( search( data, N, 11 ) == 5 ); assert( search( data, N, 102 ) == 7 ); assert( binary_search( data, N, 0 ) == 7 ); assert( binary_search( data, N, 10 ) == 7 ); assert( binary_search( data, N, 11 ) == 5 ); assert( binary_search( data, N, 102 ) == 7 ); } void run_all_tests(void) { test_is_prime(); test_print_permutations(); test_search(); } int main(void) { run_all_tests(); return 0; } Practices Illustrated\nFunctions with no parameters are declared with parameter void. We use size_t for all array index types that could potentially be large. Judicious horizontal spacing and minimal (but readable) vertical spacing. Curly braces used always (even when optional). Use of the bool type from C99\u0026rsquo;s stdbool.h. Variable names are descriptive, but not more verbose than necessary. Each solution to a problem has a piece of code to test it. « Back to Getting Started\n"}


